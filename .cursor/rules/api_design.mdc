---
description: REST API design principles, request/response standards, and frontend API integration guidelines
globs: "**/*.{js,jsx,ts,tsx,py}"
alwaysApply: true
---
# API Design Standards

## REST API Design Principles

- Use consistent, hyphenated, lowercase URL patterns: `/api/v1/resource-names` for collections, `/api/v1/resource-names/{id}` for specific items. Resource names should be plural.
  *(Rationale: Explicitly stating hyphenated lowercase and plural nouns reduces ambiguity.)*
- Follow HTTP method conventions: GET (read), POST (create), PUT (update), DELETE (remove)
- Use plural nouns for resource endpoints (e.g., `/accounts`, `/transactions`, `/books`)
- Implement appropriate HTTP status codes. Key examples:
    - `200 OK`: General success for GET, PUT/PATCH (if content returned).
    - `201 Created`: Successful creation of a new resource (POST). Response should include a `Location` header pointing to the new resource and optionally the new resource itself.
    - `204 No Content`: Successful request but no content to return (e.g., DELETE, or PUT/PATCH if no content returned).
    - `400 Bad Request`: Client-side error (e.g., malformed request syntax, invalid request message framing, or deceptive request routing, validation errors). Response body should detail errors (see 'Validation Error Response Format').
    - `401 Unauthorized`: Authentication is required and has failed or has not yet been provided.
    - `403 Forbidden`: The server understood the request, but is refusing to authorize it. The authenticated user does not have permissions for the requested resource.
    - `404 Not Found`: The requested resource could not be found.
    - `500 Internal Server Error`: A generic error message, given when an unexpected condition was encountered and no more specific message is suitable. Avoid exposing detailed error information to the client; log it server-side.
- Error messages in response bodies (especially for 4xx errors) should be clear, concise, and provide enough information for the client to understand the issue without exposing sensitive internal details. For 5xx errors, log detailed information server-side and return a generic error message to the client.
- **Idempotency**: Ensure `PUT` and `DELETE` operations are idempotent. Multiple identical requests should have the same effect as a single request. `POST` operations are typically not idempotent.
- **Date/Time Format**: Use ISO 8601 format (e.g., `YYYY-MM-DDTHH:mm:ss.sssZ`) for all date/time fields in API requests and responses to ensure consistency and avoid ambiguity.
- **PUT vs. PATCH**: Use `PUT` for full replacement of a resource. Use `PATCH` for partial updates to a resource. If `PATCH` is implemented, it should conform to the JSON Merge Patch (RFC 7396) or JSON Patch (RFC 6902) standard.

## Request/Response Standards

- Use JSON for all request and response bodies
- Include proper Content-Type headers (`application/json`)
- Implement consistent error response format with `error` and `message` fields
- Use camelCase for JSON field names in responses
  *(Rationale: This is a common convention for JavaScript-based frontends like React and improves consistency between frontend and API.)*
- For list endpoints, include pagination metadata in the response body (e.g., under a `meta` key). Standard fields should include: `totalItems: int`, `totalPages: int`, `currentPage: int`, `pageSize: int`. Query parameters for pagination should be `page: int` (1-indexed) and `pageSize: int`.
- For 400 Bad Request due to validation errors, use a consistent response format:
    ```json
    {
      "error": "ValidationFailed",
      "message": "Input validation failed.",
      "details": {
        "fieldName1": ["Error message for fieldName1.", "Another error for fieldName1."],
        "fieldName2": ["Error message for fieldName2."]
      }
    }
    ```
  *(Rationale: A defined structure helps client-side parsing and display of field-specific errors.)*

## Authentication & Authorization

- Require authentication for all endpoints except health checks and public registration/login
- Support both JWT Bearer tokens and API key authentication (`X-API-Key` header)
- Return 401 for authentication failures, 403 for authorization failures
  *(Rationale: This clearly distinguishes between 'who are you?' (401 - not authenticated or invalid credentials) and 'you are authenticated but not allowed to do this' (403 - insufficient permissions), aiding client-side logic (e.g., redirect to login vs. show access denied message) and debugging.)*

*For comprehensive security standards, see [security.mdc](mdc:.cursor/rules/security.mdc)*

## API Versioning

- Use URL path versioning: `/api/v1/`, `/api/v2/`
- Maintain backward compatibility within major versions
- Document breaking changes and migration paths
- Deprecate old API versions gracefully by providing at least 3 months' notice via API documentation and potentially `Warning` headers. Clearly document migration paths.

## Frontend API Integration

- Always use the configured `axiosInstance` from `src/api/axiosInstance.js`
  *(Rationale: This ensures consistent handling of authentication tokens (JWT), CSRF protection (if applicable), base URL configuration, request/response interceptors, and centralized error handling for all frontend API calls.)*
- Never import axios directly - use the configured instance for authentication and error handling
- In frontend API integration, wrap all `axiosInstance` calls in `try/catch` blocks. Log detailed errors to the console during development. Display user-friendly messages for API errors (e.g., from 4xx/5xx responses) or network failures/timeouts. Offer a 'retry' option where appropriate for transient network issues.
- Show loading states during API calls
- Handle network errors and timeouts gracefully
- Before implementing a client for an *existing* `kanakku` API endpoint, always verify its request structure, query parameters, expected response format (including success and error cases), and authentication requirements by:
    1.  Consulting the OpenAPI/Swagger documentation at `/api/docs`.
    2.  Reviewing the backend route definition and associated service/model code.
    3.  Examining existing frontend service functions in `src/features/*/services.js` that already interact with the endpoint.
    Do not assume field names, data types, pagination structures, or error codes without verification.
- If documentation or existing examples are unclear or missing for an API endpoint, ask for clarification before making assumptions or proceeding with implementation.
- When designing *new* API endpoints for `kanakku`, strictly adhere to the URL structure (`/api/v1/resource-names`), request/response JSON formats (camelCase fields in response), error handling (consistent error object), and authentication mechanisms defined in these rules and demonstrated in existing `kanakku` modules.
- Given the Flask backend, API responses should be generated using Flask's `jsonify` or equivalent from Flask-RESTful, ensuring correct `Content-Type: application/json` headers.
- Refer to existing `kanakku` API modules (e.g., `accounts`, `transactions` in the backend; `src/features/*/services.js` in the frontend) as the primary source of truth for established API patterns if documentation is lacking.

## Data Validation

- Validate all input data on the backend before processing
- Use appropriate data types and constraints in database models
- Return detailed validation errors with field-specific messages (See 'Validation Error Response Format' above)
- Implement input sanitization to prevent injection attacks
- Use consistent validation error response format (See 'Validation Error Response Format' above)

## Performance & Caching

- Implement appropriate database indexing for frequently queried fields
- Use pagination for large result sets
- Include ETag headers for cacheable resources
- Implement proper database connection pooling
- Monitor and log slow queries for optimization

## Documentation

- Maintain up-to-date Swagger/OpenAPI documentation at `/api/docs`
- Include example requests and responses for all endpoints
- Document all required and optional parameters
- Provide clear error code documentation
- Keep API documentation synchronized with implementation
- When documenting new API endpoints in OpenAPI/Swagger, ensure all example requests and responses are complete, accurate, and reflect the exact JSON structures, including data types and all possible fields for both success and standard error responses (400, 401, 403, 404, 500). Document the specific `error` and `message` values for each error type.

## Testing

*For comprehensive testing standards, see [testing.mdc](mdc:.cursor/rules/testing.mdc)*

## Monitoring & Logging

- Log all API requests on the server-side with details including: timestamp, request method, full path, status code, response time (duration), user ID (if authenticated), IP address, and correlation ID. For errors, include the full error stack trace.
- Include correlation IDs for request tracing
- Monitor API response times and error rates
- Implement health check endpoints for monitoring
- Set up alerts for critical API failures
