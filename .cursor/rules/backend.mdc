---
description: Flask backend development standards including database, authentication, and API design
globs: "**/*.py"
alwaysApply: true
---
# Backend Development Standards

## Flask Application Structure

- Use Flask Blueprints to organize routes by functionality (auth, accounts, transactions, etc.)
  - Flask Blueprints are the standard for modularizing features. Typically, a feature (e.g., 'accounts') will reside in `app/accounts/` and include `routes.py`, `services.py`, `models.py` (if specific to the blueprint, otherwise global models in `app/models/`), and `schemas.py` (for marshmallow).
- Follow the application factory pattern with `create_app()` function
- Keep Flask route handlers (typically in `routes.py` or `views.py` within a Blueprint) lean. Their primary responsibilities are request parsing/validation, invoking appropriate service functions for business logic, and formatting the response using data returned by service functions. All core business logic and database interactions must reside in service functions, typically located in a `services.py` file within the same Blueprint/module.
  *(Rationale: This promotes separation of concerns (SoC), making code more modular, testable, and easier to maintain.)*
- Use consistent URL patterns with `/api/v1/` prefix for all API endpoints
- Register application-wide custom error handlers using Flask's `@app.errorhandler(ExceptionType)` decorator (typically in `app/errors.py` or the main `create_app` factory). These handlers should catch specific exceptions (e.g., `ValidationError`, `SQLAlchemyError`, custom business exceptions) and generic ones (`HTTPException`, `Exception`) to return consistent JSON error responses as defined in `api_design.mdc`. Log the full error details server-side.

## Database & ORM Standards

- Use SQLAlchemy models with proper relationships and constraints
- Use Alembic for all database schema changes. After any modification to SQLAlchemy models (`app/models/`), generate a new migration script using `flask db migrate -m \"Descriptive message of changes\"`. Review the generated script for correctness before applying it with `flask db upgrade`. Avoid manual edits to migration scripts unless absolutely necessary and fully understood.
  *(Rationale: Autogenerated migrations reduce errors and ensure schema changes are version-controlled and repeatable.)*
- Use connection pooling for production deployments
- Follow naming conventions: snake_case for table and column names
- When defining SQLAlchemy models or writing queries, identify fields frequently used in `WHERE` clauses, `JOIN` conditions, or `ORDER BY` clauses, and add database indexes to optimize query performance. For composite indexes, consider the order of columns. Review existing `kanakku` models in `app/models/` for examples of index definitions.
- **Transaction Management**: For operations involving multiple database writes that must succeed or fail together (atomicity), wrap the SQLAlchemy operations within a single database transaction in your service functions. Use `db.session.begin_nested()` for finer control if needed, or rely on `db.session.commit()` at the end of the service call and ensure proper `db.session.rollback()` in error handling paths (often managed by a request teardown or error handler).
  *(Rationale: Ensures data consistency during complex operations.)*
- When writing SQLAlchemy queries, prefer explicit column selection using `.with_entities(Model.column1, Model.column2)` over fetching full model instances (`.query(Model)`) if only a few columns are needed, especially for read-heavy operations or lists. This improves performance by reducing data transfer and processing.
- Before adding new database models or relationships, carefully review existing models in `app/models/` to understand established patterns, naming conventions (e.g., `ForeignKey('tablename.id')`, `backref='related_items'`), and usage of any base model classes or mixins (e.g., a `TimestampMixin`).
- All database CRUD (Create, Read, Update, Delete) operations must be encapsulated within service functions in `services.py`. Route handlers in `routes.py` should not interact directly with SQLAlchemy models or `db.session`.

## Authentication & Security

- Use Flask-JWT-Extended for JWT token management
- Implement both JWT and API key authentication methods
- Use proper password hashing with werkzeug.security

*For comprehensive security standards, see [security.mdc](mdc:.cursor/rules/security.mdc)*

## Configuration Management

- Use environment-specific configuration classes (Development, Testing, Production)
- Use strong, randomly generated secret keys for production
- Implement proper logging configuration with different levels
- Use different database URLs for different environments
- Access application configuration values (from `config.py` and environment variables) exclusively via `current_app.config['SETTING_NAME']` within request contexts or application contexts. Do not attempt to read `os.environ` directly within application logic after startup.

*For environment variables and secrets management, see [security.mdc](mdc:.cursor/rules/security.mdc)*

## Error Handling & Logging

- Implement comprehensive error handlers that don't expose sensitive information (see "Flask Application Structure" for registration)
- Use structured logging with appropriate log levels (DEBUG, INFO, WARNING, ERROR). Backend logs should be structured (preferably JSON) to facilitate parsing and analysis by log management systems. Each log entry should include a timestamp, log level, message, logger name (module path), and relevant contextual information (e.g., request ID, user ID).
- Log security events and authentication failures
- For business logic errors, define custom exception classes (e.g., `InsufficientFundsError`, `ResourceNotFoundError` inheriting from a base `AppException`) in `app/exceptions.py`. These can then be caught by specific error handlers to return appropriate HTTP responses.
- Return consistent error response formats with meaningful messages (as per `api_design.mdc`).

## API Design & Validation

- While Flask-RESTful can be used, the primary pattern for `kanakku` is to use Flask Blueprints with route decorators (`@bp.route('/...')`). API consistency is achieved by adhering to `api_design.mdc` for URL structure, request/response formats, and status codes, and by structuring logic as described (routes -> services -> models).
- Use `marshmallow` for robust request data validation and serialization/deserialization within service functions or at the boundary of route handlers. Define marshmallow schemas for request payloads and API responses to ensure data integrity and provide clear validation error messages as per `api_design.mdc`.
- Return appropriate HTTP status codes (200, 201, 400, 401, 403, 404, 500) (as per `api_design.mdc`)
- Use JSON for all request and response bodies
- Implement pagination for endpoints that return large datasets

*For comprehensive API design standards, see [api_design.mdc](mdc:.cursor/rules/api_design.mdc)*

## Testing Standards

*For comprehensive testing standards, see [testing.mdc](mdc:.cursor/rules/testing.mdc)*

## Code Quality & Style

- Follow PEP 8 style guidelines and use Black for code formatting
- Use type hints for function parameters and return values
- Keep functions small and focused on single responsibilities
- Use descriptive variable and function names
- Add docstrings for all public functions and classes
- When creating new Flask Blueprints, route handlers, service functions, or SQLAlchemy models for `kanakku`, strictly replicate the file structure, import order (use `isort`), class/function definitions, error handling patterns, and docstring conventions found in existing, well-established modules (e.g., `app/accounts/` or `app/transactions/`). Do not invent new structural or stylistic patterns.

## Performance & Optimization

- Use database connection pooling for production deployments
- Implement proper caching strategies for frequently accessed data
- Use background tasks (Redis Queue) for long-running operations
- Monitor and log slow database queries for optimization
- Implement proper database indexing for performance

## Email & Background Processing

- Use Redis Queue (RQ) for background job processing
- Implement proper error handling and retry logic for background jobs
- Use encryption for storing sensitive email credentials
- Implement proper email validation and sanitization
- Log background job execution for monitoring and debugging

## Production Deployment

- Use Gunicorn or similar WSGI server for production deployments
- Implement proper health check endpoints for monitoring
- Use environment variables for all configuration
- Set up proper log rotation and monitoring
- Implement database backup and recovery procedures
- When refactoring backend code, focus on improving the clarity, efficiency (e.g., optimizing SQLAlchemy queries), or testability of existing service functions or model logic. Avoid changing public API contracts (URL paths, request/response formats as defined in `api_design.mdc`) unless explicitly part of the refactoring task and approved. Ensure all related tests are updated or new tests are added to cover refactored code.

*For deployment standards, see [deployment.mdc](mdc:.cursor/rules/deployment.mdc)*
